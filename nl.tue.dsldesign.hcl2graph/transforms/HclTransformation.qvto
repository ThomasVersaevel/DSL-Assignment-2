modeltype HCL uses 'http://dsldesign.tue.nl/hcl';
modeltype Graph uses 'http://dsldesign.tue.nl/graph';

	
transformation uml2relational(in hcl : HCL, out Graph);

//transformation HclTransformation();

main() {
	hcl.rootObjects()[HCL::Model]->map model2graph();
}

mapping HCL::Model::model2graph() : Graph::Graph {
	nodes := getNodes();
	name := 'HCL Model';
}

//query getComputerNodes() : Sequence(Graph::Nodes) {
//	return HCL::Computer.allInstances()-> getNodes();	
//}

query getNodes() : Sequence(Graph::Node) {
//	var components = HCL::Component.allInstances()->map component2node()->asSequence();
//	var speednodes = HCL::ProcessingUnit.allInstances()->map speed2node()->asSequence();
//	var computers = HCL::Computer.allInstances()->map computer2node()->asSequence();
//	var properties = components->
	// var cpu = object Graph::Node { label := 'CPU'; shape := Graph::Shape::BOX; };
	
	var dispNodes = HCL::DisplayUnit.allInstances()->map displayWprops2node()->asSequence()->flatten();
	var dispComponents = dispNodes->reject(e | e.label = 'HD' )->asSequence();
	var dispTypes = dispNodes->select(e | e.label = 'HD' )->asSequence();
	//var dispComponents = HCL::DisplayUnit.allInstances()->map display2node()->asSequence();
	
	var computers = HCL::Computer.allInstances()->map computer2node(dispComponents)->asSequence();
	var dispDiagonals = HCL::DisplayUnit.allInstances()->map diag2node(dispComponents)->asSequence();
	var display = mapDisplay(dispDiagonals);
	
//	var computers = HCL::Computer.allInstances()->map computer2node(dispComponents)->asSequence();
	
	return Sequence{
		display
	}->union(dispDiagonals)->union(dispComponents)->union(computers)->union(dispTypes); //->union(components)->union(speednodes);
}

//mapping HCL::Component::component2node() : Graph::Node
//disjuncts HCL::DisplayUnit::display2node, HCL::Processing::processing2node{}

helper HCL::DisplayUnit::displayWprops2node() :  Sequence(Graph::Node) {
	var type = self.map type2node();
	var comp = self.map display2node(type);
	
	return Sequence{ type, comp }
	
}

mapping HCL::Computer::computer2node(in n : Sequence(Graph::Node) ) : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
	outEdges := n->select(e | self.component->exists(c | c.label = e.label))->node2edge(Graph::Style::SOLID);
	//outEdges := n->map node2Dedge();
}

// top display node
query mapDisplay(in n : Sequence(Graph::Node)) : Graph::Node {
	return object Graph::Node { 
		label := 'Display'; 
		shape := Graph::Shape::BOX; 
		outEdges := n->node2edge(Graph::Style::SOLID);
	}
}

// display diagonals
mapping HCL::DisplayUnit::diag2node(in n : Sequence(Graph::Node)) : Graph::Node {
	shape := Graph::Shape::BOX;
	label := self.diagonal.toString() + ' ' + 'Inch';
	outEdges := n->select(e | e.label = self.label)->node2edge(Graph::Style::SOLID);
}

// display components
mapping HCL::DisplayUnit::display2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
}

mapping HCL::DisplayUnit::display2node(in t : Graph::Node) : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
	outEdges := t.node2edge(Graph::Style::DASHED);
}


mapping HCL::DisplayUnit::type2node() : Graph::Node {
	shape := Graph::Shape::OVAL;
	label := self.type.toString();
}

// EDGE
helper Graph::Node::node2edge(in s : Graph::Style) : Graph::Edge {
	return object Graph::Edge {
		style := s;
		target := self;	
	}
}