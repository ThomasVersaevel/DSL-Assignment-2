modeltype HCL uses 'http://dsldesign.tue.nl/hcl';
modeltype Graph uses 'http://dsldesign.tue.nl/graph';

	
transformation uml2relational(in hcl : HCL, out Graph);

//transformation HclTransformation();

main() {
	hcl.rootObjects()[HCL::Model]->map model2graph();
}

mapping HCL::Model::model2graph() : Graph::Graph {
//	var nodelist = List{};
	// var computers = Sequence{}->union( self.computer->map computer2node());
//	var components = self.computer.component->map component2node();
	nodes := getNodes();
	name := 'HCL Model';
}

query getNodes() : Sequence(Graph::Node) {
	var components = HCL::Component.allInstances()->map component2node()->asSequence();
	var computers = HCL::Computer.allInstances()->map computer2node()->asSequence();
//	var properties = components->
	var cpu = object Graph::Node { label := 'CPU'; shape := Graph::Shape::BOX; };
	var display = object Graph::Node { label := 'Display'; shape := Graph::Shape::BOX; };
	
	return Sequence{
		
	}->union(computers)->union(components);
}

//query getComponents() :

//helper HCL::Computer::getComputerNodes(inout n : List(Graph::Node)) {
//	n->union( self->map computer2node() )
//}


//mapping HCL::Computer::hcl2graph() : Graph::Graph {
//	var components = self.component->map component2node();
//	
//	var seq = Sequence {};
//	var props = self.component->first(). getPropNodes();
//	
//	var properties = props->union(seq);
//	
//	nodes := Sequence {
//		self.map computer2node(components)
//	}->union(components)->union(props);
//	
//	// self.component->map component2node();
////	nodes := self.map computer2node();
//}

mapping HCL::Computer::computer2node() : Graph::Node { //(in n : Sequence(Graph::Node) ) : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
	//outEdges := n->map node2Sedge();
}


helper HCL::Component::getPropNodes() : Sequence(Graph::Node) {
	if (self.oclIsKindOf(HCL::DisplayUnit)) {
		var compNode := self.map component2node();
		var typeNode := self.oclAsType(HCL::DisplayUnit).map display2node();
		var diagNode := self.oclAsType(HCL::DisplayUnit).map diag2node();
		return Sequence { compNode, typeNode, diagNode };
	} else if (self.oclIsKindOf(HCL::Processing)) {
		return Sequence { }
	};
	return Sequence { };
}

mapping HCL::Component::component2node() : Graph::Node
disjuncts HCL::DisplayUnit::display2node, HCL::Processing::processing2node{}

//mapping HCL::Component::component2node() : Graph::Node {
//		label := self.label;
//		shape := Graph::Shape::BOX;
//	if (self.oclIsKindOf(HCL::DisplayUnit)) {
//		var typeNode := self.oclAsType(HCL::DisplayUnit).map display2node();
//		outEdges := typeNode.map node2Dedge();
//		// nodes := self.
//	} else if (self.oclIsKindOf(HCL::Processing)) {
//		
//	}
//}

mapping HCL::DisplayUnit::display2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
	var dispType = self.map type2node();
	// outEdges := Sequence { dispType.map node2Dedge() };
}

// top level CPU
mapping HCL::Processing::processing2node() : Graph::Node {
	shape := Graph::Shape::BOX;
	label := 'CPU';
//	outEdges := n->map node2Sedge();
}
// top level Display
mapping HCL::Display::topdisplay2node() : Graph::Node {
	shape := Graph::Shape::BOX;
	label := 'Display';
//	outEdges := n->map node2Sedge();
}

mapping HCL::ProcessingUnit::speed2node() : Graph::Node {
	shape := Graph::Shape::BOX;
	label := self.speed.toString() + ' ' + 'GHz';
}

mapping HCL::DisplayUnit::diag2node() : Graph::Node {
	shape := Graph::Shape::OVAL;
	label := self.diagonal.toString() + ' ' + 'Inch';
}

// OVAL nodes
mapping HCL::ProcessingUnit::cores2node() : Graph::Node {
	shape := Graph::Shape::OVAL;
	label := self.cores.toString() + ' ' + 'cores';
}

mapping HCL::ProcessingUnit::cache2node() : Graph::Node {
	shape := Graph::Shape::OVAL;
	label := self.l1.size.toString() + ' ' + self.l1.magnitude.toString();
}

mapping HCL::DisplayUnit::type2node() : Graph::Node {
	shape := Graph::Shape::OVAL;
	label := self.type.toString();
}

// solid EDGE
mapping Graph::Node::node2Sedge() : Graph::Edge {
	style := Graph::Style::SOLID;
	target := self;	
}

// dashed EDGE
mapping Graph::Node::node2Dedge() : Graph::Edge {
	style := Graph::Style::DASHED;
	target := self;	
}


//query getShape() : Graph::Shape {
//	return 
//}